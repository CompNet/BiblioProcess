package fr.univavignon.biblioproc.isi;

/*
 * Biblio Process
 * Copyright 2011-2017 Vincent Labatut 
 * 
 * This file is part of Biblio Process.
 * 
 * Biblio Process is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * Biblio Process is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Biblio Process.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

import fr.univavignon.biblioproc.bibtex.JabrefFileHandler;
import fr.univavignon.biblioproc.data.Article;
import fr.univavignon.biblioproc.data.Author;
import fr.univavignon.biblioproc.tools.FileTools;

/**
 * This class compares the content of a references list generated by
 * ISI with the references contained in a JabRef file. The goal is to
 * identify the references present in the ISI file but not in the JabRef
 * one.
 *  
 * @author Vincent Labatut
 */
public class ParseSci2Network
{	
	/**
	 * Opens both input files, parses the bibliographic file to construct
	 * the list of known references, parses the ISI file to detect new
	 * references, displays the detected new references.
	 * 
	 * @param args
	 * 		Not used.
	 * 
	 * @throws FileNotFoundException
	 * 		Problem while opening the input JabRef or ISI files.
	 * @throws UnsupportedEncodingException 
	 * 		Problem while opening the input JabRef or ISI files.
	 */
	public static void main(String[] args) throws FileNotFoundException, UnsupportedEncodingException
	{	// load the JabRef file
		Map<String,Article> articleMap = JabrefFileHandler.loadJabRefFile(FileTools.FI_BIBTEX_REVIEW, true);
		
//		// update the key in the article map
//		Map<String, Article> map = new HashMap<String, Article>();
//		for(Article article: articleMap.values())
//			map.put(article.getCiteAs(), article);
//		articleMap.clear();
//		articleMap.putAll(map);
		articleList.addAll(articleMap.values());
		
		
		// open the ISI file
		System.out.println("\nOpen the ISI file " + FileTools.FI_ISI_ALL);
		Scanner sScanner = FileTools.openTextFileRead(FileTools.FI_ISI_ALL, "UTF-8");
		
		// parse the ISI file
		Article article = null;
		int count = 0;
		do
		{	count++;
//if(count==63)
//	System.out.print("");
			article = processIsiArticle(sScanner);
			System.out.println("Processing " + count + " :"+article);
		}
		while(article!=null);
		sScanner.close();
		
		// display the unknown articles
		System.out.println("\nList of unknown articles:");
		count = 0;
		Collections.sort(articleList, new Comparator<Article>()
		{	public int compare(Article o1, Article o2)
			{	int result = o1.getTimesCited() - o2.getTimesCited();
				return result;
			};
		});
		for(Article a: articleList)
		{	if(!a.isPresent())
			{	count++;
				System.out.println(count + ". [" + a.getTimesCited() + "]" + a);
			}
		}
	}
	
	/**
	 * Parses one article from the ISI file.
	 * 
	 * @param scanner
	 * 		Scanner giving access to the text.
	 * @return
	 * 		The corresponding article instance.
	 */
	private static Article processIsiArticle(Scanner scanner)
	{	Article result = null;
		if(scanner.hasNextLine())
		{	Map<String, String> data = new HashMap<String, String>();
			String line = scanner.nextLine();
			
			// get authors
			while(!line.startsWith("AU "))
			{	line = scanner.nextLine();
				if(line.startsWith("ER"))
					throw new NullPointerException();
			}
			String authors = "";
			do
			{	String author = line.substring(3);
				authors = authors + author + " and ";
				line = scanner.nextLine();
			}
			while(line.startsWith(" "));
			authors = authors.substring(0,authors.length()-5);
			data.put("author", authors);
			
			// get title
			while(!line.startsWith("TI "))
			{	line = scanner.nextLine();
				if(line.startsWith("ER"))
					throw new NullPointerException();
			}
			String title = "";
			do
			{	String temp = line.substring(3);
				title = title + temp + " ";
				line = scanner.nextLine();
			}
			while(line.startsWith(" "));
			title = title.substring(0,title.length()-1);
			data.put("title", title);
			
			// get conference
			while(!line.startsWith("SO ") && !line.startsWith("LA "))
			{	line = scanner.nextLine();
				if(line.startsWith("ER"))
					throw new NullPointerException();
			}
			if(line.startsWith("SO "))
			{	String booktitle = "";
				do
				{	String temp = line.substring(3);
					booktitle = booktitle + temp + " ";
					line = scanner.nextLine();
				}
				while(line.startsWith(" "));
				booktitle = booktitle.substring(0,booktitle.length()-1);
				data.put("booktitle", booktitle);
			}
			
			// get references
			Set<Article> citedArticles = new TreeSet<Article>(); 
			while(!line.startsWith("CR ") && !line.startsWith("NR "))
			{	line = scanner.nextLine();
				if(line.startsWith("ER"))
					throw new NullPointerException();
			}
			if(line.startsWith("CR "))
			{	do
				{	String articleStr = line.substring(3);
					Article article = Article.buildArticle(articleStr);
					if(article!=null)
					{	article = retrieveArticle(article);
						citedArticles.add(article);
					}
					line = scanner.nextLine();
				}
				while(line.startsWith(" "));
			}
			
			// get journal
			while(!line.startsWith("J9 ") && !line.startsWith("PY "))
			{	line = scanner.nextLine();
				if(line.startsWith("ER"))
					throw new NullPointerException();
			}
			if(line.startsWith("J9 "))
			{	String journal = line.substring(3);
				data.put("journal", journal);
				line = scanner.nextLine();
			}
						
			// get year
			while(!line.startsWith("PY "))
			{	line = scanner.nextLine();
				if(line.startsWith("ER"))
					throw new NullPointerException();
			}
			String year = line.substring(3);
			data.put("year", year);
			line = scanner.nextLine();
						
			// get volume
			while(!line.startsWith("VL ") && !line.startsWith("IS ")
				&& !line.startsWith("BP ") && !line.startsWith("EP ")
				&& !line.startsWith("ER"))
				line = scanner.nextLine();
			if(line.startsWith("VL "))
			{	String volume = line.substring(3);
				data.put("volume", volume);
				line = scanner.nextLine();
			}
			
			// get issue
			while(!line.startsWith("IS ")
				&& !line.startsWith("BP ") && !line.startsWith("EP ")
				&& !line.startsWith("ER"))
				line = scanner.nextLine();
			if(line.startsWith("IS "))
			{	String issue = line.substring(3);
				data.put("number", issue);
				line = scanner.nextLine();
			}
			
			// get page(s)
			while(!line.startsWith("BP ") && !line.startsWith("AR") && !line.startsWith("ER"))
				line = scanner.nextLine();
			if(line.startsWith("BP "))
			{	String pages = line.substring(3);
				line = scanner.nextLine();
				data.put("pages", pages);
			}
			while(!line.startsWith("AR ") && !line.startsWith("ER"))
				line = scanner.nextLine();
			if(line.startsWith("AR "))
			{	String pages = line.substring(3);
				line = scanner.nextLine();
				data.put("pages", pages);
			}
			
			// finish reference
			while(!line.startsWith("ER"))
				line = scanner.nextLine();
			for(int i=0;i<2;i++)
				line = scanner.nextLine();
			
			result = Article.buildArticle(data,citedArticles);
			result = retrieveArticle(result);
		}
		
		return result;
	}
	
	/**
	 * Receives the first line of a BibTex entry,
	 * and a scanner pointing on the second line,
	 * and builds the corresponding map, which can
	 * subsequently be used to build an {@link Article}
	 * object.
	 * 
	 * @param line
	 * 		First line of the BibTex entry.
	 * @param scanner
	 * 		Scanner pointing on the rest of the entry.
	 * @return
	 * 		Map containing the entry data.
	 */
	public static Map<String, String> retrieveMap(String line, Scanner scanner)
	{	// init map
		Map<String, String> result = new HashMap<String, String>();
		
		// bibtex key
		int start = line.indexOf('{') + 1;
		int end = line.length() - 1;
		String bibtexkey = line.substring(start, end);
		result.put("bibtexkey", bibtexkey);
		
		// rest of the fields
		do
		{	// get the first line for this field
			line = scanner.nextLine();
			
			if(!line.equals(ENTRY_END))
			{	// retrieve the name of the field
				int pos = line.indexOf('=');
				String fieldName = line.substring(2,pos-1);
				// retrieve the associated value
				String fieldValue = null;
				if(line.endsWith(FIELD_END))
					fieldValue = line.substring(pos+3,line.length()-2);
				else if(line.endsWith("}"))
					fieldValue = line.substring(pos+3,line.length()-1);
				else
				{	fieldValue = line.substring(pos+3);
					do
					{	line = scanner.nextLine();
						if(line.endsWith(FIELD_END))
							fieldValue = fieldValue + " " + line.substring(1,line.length()-2);
						else
							fieldValue = fieldValue + " " + line.substring(1);
					}
					while(!line.endsWith(FIELD_END));
				}
				// insert in the map
				result.put(fieldName, fieldValue);
			}
		}
		while(!line.equals(ENTRY_END));
		
		return result;
	}
	
	/////////////////////////////////////////////////////////////////
	// DATA				/////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////
	/** Map of all JabRef articles */
//	private static final Map<String,Article> articleMap = new HashMap<String, Article>();
	/** List of all articles */
	public static final List<Article> articleList = new ArrayList<Article>();
	/** Map of all authors */
	public static final Map<String,Author> authorMap = new HashMap<String, Author>();
	
	/**
	 * Retrieves an article from the article map.
	 * If it exists already, it might be completed.
	 * Otherwise, it is added to the map.
	 *  
	 * @param article
	 * 		The article to retrieve from the map.
	 * @return
	 * 		The article retrieved from the map (possibly the same object).
	 */
	private static Article retrieveArticle(Article article)
	{	// lookup the article
		Article result = null;
		Iterator<Article> it = articleList.iterator();
		while(it.hasNext() && result==null)
		{	Article a = it.next();
			if(article.isCompatible(a))
			{	result = a;
				result.incrementTimesCited();
			}
		}
		
		// update the article or list
		if(result==null)
		{	articleList.add(article);
			result = article;
		}
		else
			result.completeWith(article);
		
		return result;
	}
	
	/////////////////////////////////////////////////////////////////
	// STRINGS			/////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////
	/** String marking the end of a BibTex field */
	private static final String FIELD_END = "},";
	/** String marking the end of a BibTex entry */
	private static final String ENTRY_END = "}";
	/** String marking the end of the actual BibTex file (and the begining of the JabRef part) */
	public static final String COMMENT_PREFIX = "@comment";
	/** String marking the begining of the list of ignored articles */
	public static final String IGNORED_PREFIX = "3 ExplicitGroup:Ignored\\;2\\;";
	/** String marking the begining of the list of pureley applicative articles */
	public static final String APPLICATION_PREFIX = "3 ExplicitGroup:Applications Only\\;2\\;";
	/** String marking the end of a JabRef group */
	public static final String GROUP_END = ";;";
	/** String separating the BibTex kes in a JabRef group */
	public static final String KEY_SEPARATOR = "\\;";
}